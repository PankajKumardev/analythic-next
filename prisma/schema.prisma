datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================
// CORE: Organizations & Rate Limiting
// ============================================

model Organization {
  id           String    @id @default(uuid())
  name         String
  slug         String    @unique
  
  // The secret key used in tracking script
  secretKey    String    @unique @default(uuid())
  
  // Rate limiting (No Redis needed!)
  planTier     String    @default("FREE") // FREE, PRO
  monthlyLimit Int       @default(5000)   // FREE: 5k, PRO: 100k
  currentUsage Int       @default(0)
  lastReset    DateTime  @default(now())
  
  // Relations
  projects     Project[]
  users        UserOrganization[]
  subscription Subscription?
  
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  
  @@index([secretKey])
}

// ============================================
// BILLING: Dodo Payments Integration
// ============================================

model Subscription {
  id               String       @id @default(uuid())
  orgId            String       @unique
  org              Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  
  subscriptionId   String       @unique // From Dodo
  customerId       String              // From Dodo
  status           String              // active, past_due, cancelled
  currentPeriodEnd DateTime
  
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
}

// ============================================
// ANALYTICS: Projects & Aggregated Daily Stats
// ============================================

model Project {
  id          String      @id @default(uuid())
  name        String
  domain      String?     // Optional: example.com
  
  // Security: Separate keys for different purposes
  writeKey    String      @unique @default(uuid()) // Used in tracker script
  
  orgId       String
  org         Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  
  dailyStats  DailyStat[]
  
  createdAt   DateTime    @default(now())
  
  @@index([orgId])
  @@index([writeKey])
}

model DailyStat {
  id          String   @id @default(uuid())
  projectId   String
  date        DateTime @db.Date
  
  // JSONB columns for flexible aggregation
  // Example: { "/home": 1250, "/pricing": 340, "/blog/post-1": 89 }
  pageViews   Json     @default("{}")
  
  // Example: { "IN": 890, "US": 234, "UK": 76 }
  countries   Json     @default("{}")
  
  // Example: { "Chrome": 450, "Safari": 320, "Firefox": 130 }
  browsers    Json     @default("{}")
  
  // Example: { "1920x1080": 340, "1366x768": 290, "mobile": 270 }
  screens     Json     @default("{}")
  
  // Example: { "google.com": 234, "twitter.com": 120, "direct": 546 }
  referrers   Json     @default("{}")
  
  // Track if data has been aggregated
  aggregated  Boolean  @default(false)
  
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  @@unique([projectId, date])
  @@index([date])
  @@index([aggregated])
}

// ============================================
// AUTH: Users & Organizations
// ============================================

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password      String?   // Hashed password for email/password auth (null for OAuth users)
  name          String?
  image         String?
  emailVerified DateTime? // For email verification
  
  organizations UserOrganization[]
  accounts      Account[]
  sessions      Session[]
  
  createdAt     DateTime  @default(now())
}

model UserOrganization {
  id     String @id @default(uuid())
  userId String
  orgId  String
  role   String @default("MEMBER") // OWNER, ADMIN, MEMBER
  
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  
  @@unique([userId, orgId])
}

// NextAuth required tables
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
